// lib/workoutGenerator.js - V3_SCHEMA_UPDATE_MARKER_GENERATOR
import _ from 'lodash';

// --- Helper Functions ---

function calculateTargetPace(cssSecondsPer100, paceConfig) {
    if (!paceConfig || typeof cssSecondsPer100 !== 'number') {
        return cssSecondsPer100;
    }
    let pace = cssSecondsPer100;
    const offset = paceConfig.offset || 0;
    const randomRange = paceConfig.randomRange || 0;
    let randomComponent = 0;
    if (randomRange > 0) {
        randomComponent = Math.random() * randomRange;
    }
    const totalAdjustment = offset + randomComponent;
    if (paceConfig.operator === "+") {
        pace += totalAdjustment;
    } else if (paceConfig.operator === "-") {
        pace -= totalAdjustment;
    }
    return pace;
}

function formatDescriptiveMessage(template, params) {
    if (!template) return "No descriptive message template provided.";
    let message = template;
    for (const key in params) {
        if (params[key] !== undefined) {
            message = message.replace(new RegExp(`{${key}}`, 'g'), params[key]);
        }
    }
    message = message.replace(/{[^}]+}/g, '');
    return message.trim();
}

function formatSetString(setInfo, energySystem, formatConfig) {
    let structure = formatConfig.baseStructure || "{reps}x{dist} {activity} ({energySystem} focus) {rest}";
    structure = structure.replace("{reps}", setInfo.reps);
    structure = structure.replace("{dist}", setInfo.dist);
    structure = structure.replace("{activity}", setInfo.activity || formatConfig.defaultActivity || "swim");
    structure = structure.replace("{energySystem}", energySystem);
    structure = structure.replace("{rest}", setInfo.restString || "");
    structure = structure.replace("{paceDesc}", setInfo.paceDesc || "");
    structure = structure.replace("{notes}", setInfo.notes || ""); // Added notes
    structure = structure.trim().replace(/\s\s+/g, ' ').replace(/\s\(@/g, ' @').replace(/\s\(\s*,/g, ' (').replace(/,\s*\)/g, ')').replace(/\(\s*\)/g, ''); // Clean up
    if (setInfo.setRest === "rest 0 seconds") {
        return structure;
    } else {
        return structure + "\n  - " + setInfo.setRest;
    }
}

// --- Main Generator Function ---
export function generateMainSetFromConfig(energySystem, cssSecondsPer100, remainingDistanceForMainSet, strategyConfig) {
    let sets = [];
    let mainSetTotalDist = 0;
    let targetPacePer100 = 0;
    let descriptiveMessage = "";

    if (!strategyConfig) {
        return { sets, mainSetTotalDist, targetPacePer100, descriptiveMessage: "Error: Workout configuration not provided." };
    }

    targetPacePer100 = calculateTargetPace(cssSecondsPer100, strategyConfig.paceConfig);

    const strategyResult = generateSet(strategyConfig, remainingDistanceForMainSet)
    const paceDescription = generatePaceSummary(strategyConfig);

    if (strategyResult && strategyResult.generatedSets && strategyResult.generatedSets.length > 0 && strategyResult.totalDistance > 0) {
        mainSetTotalDist = strategyResult.totalDistance;
        strategyResult.generatedSets.forEach(item => {
            sets.push(formatSetString(item, energySystem, strategyConfig.setFormatting));
        });

        descriptiveMessage = formatDescriptiveMessage(strategyConfig.descriptiveMessages.success, {
            workoutTypeName: strategyConfig.workoutTypeName,
            setSummary: strategyResult.strategySpecificSummary || "Set generated",
            energySystem: energySystem,
            totalDistance: String(mainSetTotalDist),
            paceDescription
        });

    } else {
        mainSetTotalDist = 0;
        descriptiveMessage = formatDescriptiveMessage(strategyConfig.descriptiveMessages.fail, {
            workoutTypeName: strategyConfig.workoutTypeName,
            energySystem: energySystem,
            totalDistance: String(remainingDistanceForMainSet),
            setSummary: strategyResult?.strategySpecificSummary || "No sets generated by strategy.",
            paceDescription
        });
    }

    return { sets, mainSetTotalDist, targetPacePer100, descriptiveMessage };
}

function generatePaceSummary(strategyConfig) {
    let paceSummaryText = "CSS";
    if (strategyConfig && strategyConfig.paceConfig) {
        const pc = strategyConfig.paceConfig;
        if (pc.offset === 0 && !pc.randomRange) { /* paceSummaryText already "CSS" */ }
        else if (pc.operator && (pc.offset || pc.randomRange)) {
            let basePaceDesc = "CSS ";
            let offsetPart = "";
            if (pc.offset) {
                offsetPart = `${pc.operator}${pc.offset}`;
            }
            if (pc.randomRange) {
                const rangeEnd = pc.offset + pc.randomRange;
                if (pc.offset && Math.abs(rangeEnd) !== Math.abs(pc.offset)) {
                    offsetPart += `-${Math.abs(rangeEnd)}`;
                } else if (!pc.offset) {
                    offsetPart = `${pc.operator}0-${Math.abs(pc.randomRange)}`;
                }
            }
            paceSummaryText = basePaceDesc + offsetPart + "s/100m";
        }
    }
    return paceSummaryText;
}

function generateSet(strategyConfig, setDistance) {
    let remainingDistance = setDistance;

    const { setDefinitions } = strategyConfig; 
    const shuffledSetDefinitions = _.shuffle(setDefinitions);
    const output = {
        generatedSets: [],
        totalDistance: 0, //bestOption.totalYardage,
        strategySpecificSummary: "", //`${bestOption.reps}x${chosenSetDef.distance}` 
    }; 

    for (const setDef of shuffledSetDefinitions) { // Iterate over shuffledSetDefinitions
        const currentDist = setDef.distance;
        if (setDef.repScheme.type === "dynamic" && remainingDistance >= currentDist) {
            let currentReps = Math.floor(remainingDistance / currentDist);
            if (currentReps === 0) continue;

            const maxReps = setDef.repScheme.maxReps || Infinity;
            currentReps = Math.min(currentReps, maxReps);
            
            if (currentReps > 0) {
                const currentTotalYardage = currentReps * currentDist;
                remainingDistance -= currentTotalYardage;

                const rest = `r${setDef.rest}`;
                const setInfo = {
                    reps: currentReps,
                    dist: setDef.distance,
                    restString: rest,
                    activity: setDef.activity || strategyConfig.setFormatting.defaultActivity || "kick",  
                    setRest: `rest ${strategyConfig.setRest} seconds`,
                    rest
                };

                output.generatedSets.push(setInfo);
                output.totalDistance += currentTotalYardage;
                output.strategySpecificSummary += `${currentReps}x${setDef.distance}\n`;
            }
        }
    }

    if (output.generatedSets.length) {
        return output;
    }
    return { generatedSets: [], totalDistance: 0, strategySpecificSummary: "No suitable reps found." };
}